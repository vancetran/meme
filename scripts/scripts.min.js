'use strict';
/**
 * @ngdoc overview
 * @name memekitApp
 * @description
 * # memekitApp
 *
 * Main module of the application.
 */

(function(){

var app = angular
  .module('memekit', [
    'ngCookies',
    'ngResource',
    'ngRoute',
    'ngSanitize',
    //'ngTouch',
    'colorpicker.module',
    'draganddrop',
    'ui.router'
]);

app.config(function ($stateProvider, $urlRouterProvider) {
  // For any unmatched url, redirect to /
  $urlRouterProvider.otherwise('/');

  // Now set up the states
  $stateProvider
    .state('index', {
      url: '/',
      controller: 'MainCtrl',
      templateUrl: 'views/main.html',
      resolve: {
        themeConfig: function(themeConfigProvider) {
          return themeConfigProvider;
        }
      }
    });

});

})();

'use strict';

/**
 * @ngdoc function
 * @name memekit.controller:MainCtrl
 * @description
 * # MainCtrl
 * Controller of the memekit
 */


(function(){


var app = angular.module('memekit')
  .controller('MainCtrl', function ($scope, saveSvgAsPng, themeConfig) {

    $scope.config = {
      sizes: [
        {
          name: 'Facebook',
          width: 800,
          height: 370,
        },
        {
          name: 'Twitter',
          width: 650,
          height: 320,
        },
        {
          name: 'Instagram',
          width: 640,
          height: 640,
        },
        {
          name: 'Video',
          width: 640,
          height: 360,
        },
      ],
      themes: themeConfig,
      output: {
        scale: 2,
        editable: {
          scale: true
        }
      },
      svg: {
        canvas: {
          height: function() {
            return $scope.size.height;
          },
          width: function() {
            return $scope.size.width;
          },
        },
        elements: [
          {
            name: 'Headline',
            type: 'text',
            text: 'Edit this text, and drag it around.\n\nYou can upload your own background image,\nlogo, and change the colour of the text too.',
            // text: function() {
            //   return $scope.theme.headlineText || 'Edit this text, and drag it around.\n\nYou can upload your own background image,\nlogo, and change the colour of the text too.';
            // },
            fill: function() {
              return $scope.theme.headline;
            },
            fontSize: 26,
            fontFamily: function() {
              return $scope.theme.headlineFont;
            },
            textAnchor: 'start',
            x: 30,
            y: 55,
            draggable: true,
            collapsed: false,
            editable: {
              text: true,
              fill: 'picker',
              textAnchor: true,
              fontSize: {
                'Small (18px)': 18,
                'Medium (26px)': 26,
                'Large (32px)': 32,
                'Extra Large (40px)': 40,
                'Largest (72px)': 72,
              },
            },
          },
          {
            name: 'Credit',
            type: 'text',
            text: 'Credit: Insert name here',
            fill: function() {
              return $scope.theme.quote;
            },
            fontSize: 12,
            fontFamily: function() {
              return $scope.theme.headlineFont;
            },
            textAnchor: 'start',
            x: 30,
            y: function(){
              return $scope.size.height - 120;
            },
            collapsed: true,
            draggable: true,
            editable: {
              text: true,
              fontSize: {
                'Small (12px)' : 12,
                'Medium (18px)': 18,
                'Large (22px)': 22,
                'Extra Large (36px)': 36,
                'Largest (42px)': 42
              },
              fill: 'picker',
              textAnchor: true
            },
          },
          {
            name: 'Background Color',
            type: 'rect',
            height: function() {
              return $scope.size.height;
            },
            width: function() {
              return $scope.size.width;
            },
            fill: function() {
              return $scope.theme.background;
            },
            collapsed: true,
            editable: {
              fill: 'picker'
            }
          },
          {
            name: 'Image',
            type: 'image',
            width: 600,
            height: function() {
              return this.width;
            },
            src: '',
            opacity: 1,
            x: '0%',
            y: '0%',
            preserveAspectRatio: 'xMinYMin meet',
            collapsed: true,
            draggable: true,
            defaultFilter: '',
            editable: {
              src: true,
              width: true,
              opacity: true,
              filters: [
                'Sepia',
                'Grayscale',
                'Invert',
                'Blur'
              ],
            }
          },
          {
            name: 'Logo',
            type: 'image',
            width: 150,
            height: function() {
              return this.width;
            },
            src: function() {
              return $scope.theme.logoSrc;
            },
            opacity: 1,
            x: 30,
            y: function(){
              return $scope.size.height - 100;
            },
            preserveAspectRatio: 'xMinYMin meet',
            editable: {
              src: true,
              width: true,
            },
            collapsed: true,
            draggable: true
          },

        ],
      }
    };

    function createConfigCopy() {
      $scope.defaultConfig = angular.copy($scope.config);
      $scope.$broadcast('resetSvg');
    }

    var wizardIntro = false;

    if (wizardIntro){
      if(typeof $scope.config.themes !== 'undefined') {
        $scope.theme = ($scope.config.themes.length > 1) ? null : $scope.config.themes[0];
      }

      $scope.size = ($scope.config.sizes.length > 1) ? $scope.config.sizes[0] : $scope.config.sizes[0];
    }else{
      if(typeof $scope.config.themes !== 'undefined') {
        $scope.theme = $scope.config.themes[0];
      }
      $scope.size = $scope.config.sizes[0];
    }

    $scope.$watch('theme', function() {
      $scope.$broadcast('changeTheme');
      createConfigCopy();
    });

    $scope.$watch('size', function() {
      $scope.$broadcast('changeSize');
      createConfigCopy();
    });

    $scope.resetSvg = function() {
      $scope.config.svg = $scope.defaultConfig.svg
      createConfigCopy();
    };

    // Drop handler.
    $scope.onDrop = function (data, event, key) {
      var dataTransfer = getDataTransfer(event);
      readFile(dataTransfer.files[0], key);
    };

    $scope.fileChanged = function(file) {
      readFile(angular.element(file)[0].files[0], angular.element(file)[0].dataset.key);
    };

    // Read the supplied file (from DataTransfer API)
    function readFile(file, key) {
      var reader = new FileReader();

      reader.onload = function() {
        $scope.config.svg.elements[key].src = reader.result;
        $scope.$apply();
      };

      reader.readAsDataURL(file);
    }

    // Get the data transfer
    function getDataTransfer(event) {
      event.stopPropagation();
      event.preventDefault();
      return event.dataTransfer || null;
    }

    $scope.removeImage = function(key) {
      $scope.config.svg.elements[key].src = '';
    };

    $scope.downloadSvg = function() {
      saveSvgAsPng(document.getElementById('snap-svg'), 'meme-'+ $scope.getFilename() +'.png', {
        scale: $scope.config.output.scale
      });
    };

    $scope.getFilename = function() {
      var elements = $scope.config.svg.elements;
      var quote = '';

      // grab headline string
      if(elements[4].name === 'Headline' ){
        quote = elements[4].text;
      }else{
        for (var x in elements){
          if(elements[x].name === 'Headline' ){
            quote = elements[x].text;
            break;
          }
        }
      }

      // convert to array, limit to 5 words
      quote = quote.split(' ', 5);

      // join back to string, remove spare characters and replace spaces with dashes
      var filename = $scope.slugify( quote.join(' ') );
      return filename;
    };

    $scope.slugify = function(text) {
      return text
        .toLowerCase()
        .replace(/[^\w ]+/g,'')
        .replace(/ +/g,'-');
    };
  });


})();

'use strict';

/**
 * @ngdoc service
 * @name memekit.snapSVG
 * @description
 * # snapSVG
 * Service in the memekit.
*/
(function(){
var app = angular.module('memekit')
  .service('snapSVG', function snapSVG($window) {
    return $window.Snap;
  });
})();

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:snapSvg
 * @description
 * # snapSvg
*/
angular.module('memekit')
  .directive('snapSvg', function(snapSVG) {
    return {
      template: '<svg id="snap-svg"></svg>',
      restrict: 'E',
      scope: {
        svgConfig: '=',
        svgTheme: '=',
      },
      link: function postLink(scope, element) {
        // Check for functions in the config, and resolve them
        function functionise(element) {
          var attrs = {};
          for (var item in element) {
            switch (typeof element[item]) {
              case 'function':
                attrs[item] = element[item]();
                // if (item === "fill") {
                //   console.log("Function, item: " + item);
                //   console.log(attrs[item]);
                // }
                break;
              default:
                attrs[item] = element[item];
                break;
            }
          }
          return attrs;
        }

        // Inlines all styles
        function styles(el, selectorRemap) {
          var css = '';
          var sheets = document.styleSheets;
          for (var i = 0; i < sheets.length; i++) {
            if (isExternal(sheets[i].href)) {
              console.warn('Cannot include styles from other hosts: ' +
                sheets[i].href);
              continue;
            }
            var rules = sheets[i].cssRules;
            if (rules !== null) {
              for (var j = 0; j < rules.length; j++) {
                var rule = rules[j];
                if (typeof(rule.style) !== 'undefined') {
                  try {
                    var matches = el.querySelectorAll(rule.selectorText);
                    if (matches.length > 0) {
                      var selector = selectorRemap ? selectorRemap(rule.selectorText) :
                        rule.selectorText;
                      css += selector + ' { ' + rule.style.cssText +
                        ' }\n';
                    } else if (rule.cssText.match(/^@font-face/)) {
                      css += rule.cssText + '\n';
                    }
                  } catch (e) {
                    // Do nothing
                  }
                }
              }
            }
          }
          return css;
        }

        // Checks for external files and ignores them
        function isExternal(url) {
          return url && url.lastIndexOf('http', 0) === 0 && url.lastIndexOf(
            window.location.host) === -1;
        }

        // Destringify the JSON object
        var data = angular.fromJson(scope.svgConfig);

        // Custom SVG Drag function, given that we scale the SVG
        snapSVG.plugin(function(Snap, Element) {
          Element.prototype.altDrag = function() {
            this.drag(dragMove, dragStart, dragEnd);
            return this;
          };

          var dragStart = function() {
            this.data('ot', this.transform()
              .local);
          };

          var dragMove = function(dx, dy) {
            var tdx, tdy;
            var snapInvMatrix = this.transform()
              .diffMatrix.invert();
            snapInvMatrix.e = snapInvMatrix.f = 0;
            tdx = snapInvMatrix.x(dx, dy);
            tdy = snapInvMatrix.y(dx, dy);
            this.transform(this.data('ot') + 't' + [tdx, tdy]);
          };

          var dragEnd = function() {};
        });

        // Setup element
        var s = snapSVG(element[0].children[0]);
        s.attr({
          height: '100%',
          width: '100%',
        });

        // Generate all our styles and put them inside the <defs> attribute of the SVG
        // This is done as early as possible to ensure all webfonts declared via @font-face are included appropriately
        // @TODO: Find a smarter way of defining any external fonts via config, and process them here
        var stylesElement = s.paper.el('style', {
          type: 'text/css'
        });
        var css = styles(s.node);
        stylesElement.node.innerHTML = css;
        stylesElement.toDefs();

        // Setup canvas background
        var canvasData = functionise(data.canvas);
        var background = s.rect(0, 0, canvasData.width, canvasData.height,
            0, 0)
          .attr(canvasData);
        if (canvasData.draggable === true) {
          background.altDrag();
        }

        // Create us some filters for later use
        var filters;

        function setupFilters() {
          // Store filters
          filters = {
            'Sepia': s.paper.filter(snapSVG.filter.sepia(1))
              .attr({
                width: canvasData.width * 4 + 'px',
                height: canvasData.height * 4 + 'px'
              }),
            'Grayscale': s.paper.filter(snapSVG.filter.grayscale(1))
              .attr({
                width: canvasData.width * 4 + 'px',
                height: canvasData.height * 4 + 'px'
              }),
            'Saturate': s.paper.filter(snapSVG.filter.saturate(0.5))
              .attr({
                width: canvasData.width * 4 + 'px',
                height: canvasData.height * 4 + 'px'
              }),
            'Invert': s.paper.filter(snapSVG.filter.invert(1))
              .attr({
                width: canvasData.width * 4 + 'px',
                height: canvasData.height * 4 + 'px'
              }),
            'Blur': s.paper.filter(snapSVG.filter.blur(4, 4))
              .attr({
                width: canvasData.width * 4 + 'px',
                height: canvasData.height * 4 + 'px'
              }),
          };
        }
        setupFilters();

        // Setup some element variables
        var elements = [],
          el;

        // The function that sets up the element with the required settings
        function setupElement(element) {
          var el;
          element = functionise(element);

          switch (element.type) {
            case 'text':
              el = s.text(element.x, element.y);
              break;
            case 'image':
              el = s.image(element.src, element.x, element.y, element.width,
                element.height);
              break;
            case 'rect':
              el = s.rect(element.x, element.y, element.width, element.height,
                0, 0);
              break;
            case 'circle':
              break;
            case 'group':
              var gEl;
              el = '';
              angular.forEach(element.elements, function(e, k) {
                gEl = setupElement(e);
                setAttributes(gEl, e);

                if (k === 0) {
                  el = s.group(gEl);
                } else {
                  el.group(gEl);
                }
              });
              break;
            default:
              return false;
          }

          /** Filters **/
          if (typeof element.defaultFilter !== 'undefined') {
            if (element.defaultFilter !== '') {
              el.attr({
                filter: filters[element.defaultFilter]
              });
            } else {
              el.attr({
                filter: ''
              });
            }
          }

          return el;

        }

        // Setup our atrribtes on the specific element
        function setAttributes(el, element) {
          var attrs = functionise(element);
          var elementData = attrs;
          delete elementData.$$hashKey;
          if (elementData.type === 'text') {
            elementData.text = elementData.text.split('\n');
          }

          el.attr(elementData);

          if (elementData.type === 'text') {
            el.selectAll('tspan')
              .forEach(function(tspan, i) {
                tspan.attr({
                  x: elementData.x,
                  y: elementData.y + (elementData.fontSize * i)
                });
              });
          }

          return el;
        }

        // Draw the elements on the SVG
        function drawElements() {
          // Make changes to the canvas
          var canvasData = functionise(scope.svgConfig.canvas);

          s.attr({
            viewBox: '0, 0, ' + canvasData.width + ', ' + canvasData.height,
            'data-width': canvasData.width,
            'data-height': canvasData.height
          });
          setAttributes(background, scope.svgConfig.canvas);

          var matrix;

          // Loop through all elements
          angular.forEach(scope.svgConfig.elements, function(element, key) {
            // Check if we have setup the element already
            if (typeof elements[key] !== 'undefined') {
              // The element already exists
              el = elements[key];

              // If the type is image
              if (el.type === 'image') {
                // Store matrix transformation, we'll need it later to prevent the image moving around the SVG when replaced
                matrix = el.matrix;

                // Create new element based on config
                var newEl = setupElement(scope.svgConfig.elements[key]);

                if (newEl === false) {
                  return;
                }

                // Place new element directly after old one
                el.after(newEl);

                // Apply matrix transformation from previous element
                newEl.transform(matrix);

                // Destroy old element
                el.remove();

                el = newEl;

                // Add the created element to a list of elements
                elements[key] = el;
              }

              if (el.type === 'g') {
                // Store matrix transformation, we'll need it later to prevent the group moving around the SVG when replaced
                matrix = el.matrix;

                // Destroy and recreate
                el.remove();

                // Create new element based on config
                el = setupElement(scope.svgConfig.elements[key]);

                if (el === false) {
                  return;
                }

                // Apply matrix transformation from previous element
                el.transform(matrix);

                // Add the created element to a list of elements
                elements[key] = el;
              }
            } else {
              // Create new element based on config
              el = setupElement(element);

              if (el === false) {
                return;
              }

              // Add the created element to a list of elements
              elements.push(el);
            }

            // Update the attributes (e.g. text and colours) based on config data
            var elementData = element;
            delete elementData.$$hashKey;

            // Update the element!
            setAttributes(el, element);

            // Check if we're to enable dragging
            if (element.draggable === true) {
              // We have to 'undrag' the element here, because they can get choppy after a few redraws otherwise
              el.undrag();

              // Drag dat
              el.altDrag();
            }
          });
          reorderSvgElements();
        }

        function resetSvg() {
          var els = s.selectAll('*');
          angular.forEach(els, function(e, i) {
            e.transform('');
          });
        }

        // moves Headline and Credit SVG elements to the bottom of SVG, so they'll show up on top of the z-index pile
        var reorderSvgElements = function() {
          var headline = document.querySelector(
            "#snap-svg text[name=Headline]");
          var credit = document.querySelector(
            "#snap-svg text[name=Credit]");
          document.getElementById('snap-svg')
            .appendChild(headline);
          document.getElementById('snap-svg')
            .appendChild(credit);
        };

        // Watch for changes on the scope and the theme, and redraw
        scope.$watch('svgConfig', drawElements, true);
        scope.$on('changeTheme', drawElements);
        scope.$on('changeSize', drawElements);
        scope.$on('changeSize', setupFilters);
        scope.$on('resetSvg', resetSvg);
      }
    };
  });

'use strict';

/**
 * @ngdoc service
 * @name memekit.saveSvgAsPng
 * @description
 * # saveSvgAsPng
 * Service in the memekit.
*/

(function(){
var app = angular.module('memekit')
  .service('saveSvgAsPng', function ($window) {
    return $window.saveSvgAsPng;
  });
})();

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:fixedScroll
 * @description
 * # fixedScroll
 */
angular.module('memekit')
  .directive('fixedScroll', function ($window) {
    return function(scope, element) {
      var rect = element[0].getBoundingClientRect();
      var offset = rect.top - 20;

    	angular.element($window).bind('scroll', function() {
    		if(document.body.scrollTop >= offset) {
    			element.addClass('fixed');
    		} else {
    			element.removeClass('fixed');
    		}
    	});
   	};
  });

'use strict';

/**
 * @ngdoc provider
 * @name memekit.themeConfigProvider
 * @description
 * # themeConfigProvider
 * Service in the memekit.
*/

(function(){

var app = angular.module('memekit')
  .provider('themeConfigProvider', function () {
  	return {
  	  $get: function($http, $q) {
  			var defaultConfig = $http.get('themes.config.json').catch(function(err) {
  				if(err.status === 404) {
  					return [];
  				}

  				return $q.reject(err);
  			});

  			return $q.all([defaultConfig]).then(function(values){
  				return values[0].data;
  			});
  		}
  	};
  });
})();

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:textEditor
 * @description
 * # textEditor
 */
angular.module('memekit')
  .directive('textEditor', function () {
    return {
      template: '<div><label for="texteditor-{{element.name}}">Text</label><textarea id="texteditor-{{element.name}}" ng-model="element.text" class="form-control" placeholder="Caption"></textarea></div>',
      restrict: 'E',
      replace: true,
  	  scope: {
  	    element: '='
  	  }
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:fillEditor
 * @description
 * # fillEditor
 */
angular.module('memekit')
  .directive('fillEditor', function () {
    return {
      template: '<div><label for="filleditor-{{element.name}}">Fill Color</label><input colorpicker id="filleditor-{{element.name}}" type="text" ng-model="element.fill" ng-if="field == \'picker\'" class="form-control" /><select ng-model="element.fill" ng-options="name for (name, value) in field" class="form-control" ng-if="field != \'picker\'"><option value="">-- Select a Fill Color --</option></select></div>',
      restrict: 'E',
      scope: {
      	field: '=',
      	element: '='
      },
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:fontsizeEditor
 * @description
 * # fontsizeEditor
 */
angular.module('memekit')
  .directive('fontsizeEditor', function () {
    return {
      template: '<div>'+
            '<label for="fontsizeeditor-{{element.name}}">Font Size</label>'+
            '<select id="fontsizeeditor-{{element.name}}" ng-model="element.fontSize" ng-options="name for (name, value) in field" class="form-control">'+
              '<option value="">-- Select a Font Size --</option>'+
            '</select>'+
          '</div>',
      restrict: 'E',
      replace: true,
  	  scope: {
      	element: '=',
  	    field: '='
  	  },
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:fontfamilyEditor
 * @description
 * # fontfamilyEditor
 */
angular.module('memekit')
  .directive('fontfamilyEditor', function () {
    return {
      template: '<div>' +
            '<label for="fonteditor-{{element.name}}">Font Family</label>' +
            '<select id="fonteditor-{{element.name}}" ng-model="element.fontFamily" ng-options="name for (name, value) in field" class="form-control">' +
              '<option value="">-- Select a Font Family --</option>' +
            '</select>' +
          '</div>',
      restrict: 'E',
      replace: true,
  	  scope: {
  	    element: '=',
  	    field: '='
  	  },
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:imageEditor
 * @description
 * # imageEditor
 */
angular.module('memekit')
  .directive('imageEditor', function () {
    return {
      template: '<div>' +
            '<label>Image</label>' +
            '<div class="dropzone" drop="onDrop($data, $event, key)" drop-effect="copy" drop-accept="\'Files\'" drag-over-class="drag-over-accept">' +

              '<div class="fileInputWrapper button">' +
                '<span>or select an image</span>' +
                '<input onchange="angular.element(this).scope().$parent.fileChanged(this, event)" data-key="{{key}}" type="file" accept="image/*" />' +
              '</div>' +

            '</div>' +
            '<button ng-show="config.elements[key].src !== \'\'" ng-click="removeImage(key)" class="button button-danger"><i class="icon-x"></i> Remove Image</button>' +
          '</div>',
      restrict: 'E',
      scope: {
        key: '=',
        onDrop: '=',
        removeImage: '=',
      },
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:sizeEditor
 * @description
 * # sizeEditor
 */
angular.module('memekit')
  .directive('sizeEditor', function () {
    return {
      template: '<div>' +
            '<label for="sizeeditor-{{element.name}}">Size</label>' +
            '<input id="sizeeditor-{{element.name}}" type="range" min="10" max="2000" ng-model="element.width" />' +
          '</div>',
      restrict: 'E',
      replace: true,
  	  scope: {
  	    element: '=',
  	  },
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:textanchorEditor
 * @description
 * # textanchorEditor
 */
angular.module('memekit')
  .directive('textanchorEditor', function () {
    return {
      template: '<div>' +
            '<label for="filtereditor-{{element.name}}">Text Anchor</label>' +
            '<select id="filtereditor-{{element.name}}" ng-model="element.textAnchor" class="form-control">' +
              '<option value="">-- Select a Text Anchor --</option>' +
              '<option value="start">Start</option>' +
              '<option value="middle">Middle</option>' +
              '<option value="end">End</option>' +
            '</select>' +
          '</div>',
      restrict: 'E',
      replace: true,
  	  scope: {
  	    element: '='
  	  },
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:opacityEditor
 * @description
 * # opacityEditor
 */
angular.module('memekit')
  .directive('opacityEditor', function () {
    return {
      template: '<div>' +
            '<label for="opacityeditor-{{element.name}}">Opacity</label>' +
            '<input id="opacityeditor-{{element.name}}" type="range" min="0" max="1" ng-model="element.opacity" step="0.05" />' +
          '</div>',
      restrict: 'E',
      replace: true,
  	  scope: {
  	    element: '=element'
  	  },
    };
  });

'use strict';

/**
 * @ngdoc directive
 * @name memekit.directive:filterEditor
 * @description
 * # filterEditor
 */
angular.module('memekit')
  .directive('filterEditor', function () {
    return {
      template: '<div>' +
            '<label for="filtereditor-{{element.name}}">Filter</label>' +
            '<select id="filtereditor-{{element.name}}" ng-model="element.defaultFilter" ng-options="filter for filter in filters" class="form-control">' +
              '<option value="">No filter</option>' +
            '</select>' +
          '</div>',
      replace: true,
      restrict: 'E',
  	  scope: {
  	    element: '=',
  	    filters: '='
  	  },
    };
  });
